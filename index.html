<!DOCTYPE html>
<html>

<head>
	<link rel="stylesheet" href="docs/base.css">
	<link rel="stylesheet" type="text/css" href="docs/lua-web-cli.css">
	<link rel="stylesheet" type="text/css" href="docs/github.css">
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.6.0/build/styles/default.min.css">
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1,  maximum-scale=1,  minimum-scale=1, user-scalable=no">
	<title>bioscript</title>
</head>

<body>
<div class="wrapper">
	<!--
<div class="sidebar">
  <a class="active" href="#bioscript">Bioscript</a>
  <a href="#protocols">Protocols</a>
  <a href="#mixtures">Mixtures</a>
  <a href="#repl">REPL</a>
</div>
	-->

<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/languages/lua.min.js"></script>
<script>
hljs.configure({ cssSelector: 'code' });;
hljs.highlightAll();
</script>

<div class="page">

<div id="bioscript">
<h1>Bioscript</h1>
<p>Bioscript is a programming language that describes both the digital representation <i>and</i> the physical execution of biological experiments. Bioscript is able to digitally simulate procedures like PCR while at the same time describing how physical execution would work through mixing and heating steps.</p>

<p>Bioscript's primary objective is to make biological experiments reproducible. Practically speaking, this means bioscript protocols are <i>objective</i>, <i>higher-level</i>, and <i>stable</i>.</p>

<p>Right now, Bioscript can only execute on Trilobio machines.</p>

<h3>Objective</h3>
<p>All bioscript protocols are <i>objectively defined</i>, meaning all inputs that can possibly be known are described. While chemicals or sequences may have human readable names, the underlying data is tracked by objective identifiers, like <a href="https://iupac.org/who-we-are/divisions/division-details/inchi/">InChIs</a> for chemicals or hashes of sequences themselves.</p>
<p>This allows protocols to execute without material ambiguity.</p>

<h3>Higher level</h3>
<p>Bioscript protocols describe actions in a biological experiment at a <i>higher level</i> of abstraction. For example, instead of "pipette 10uL from A1 to B2", a bioscript command would be "make (this) mixture", and then the system executing bioscript figures out the actions necessary to accomplish that goal in a particular lab environment.</p>
<p>This decouples protocols from the particular lab setup that they are executed in, allowing any lab to execute the same <i>higher level</i> experiment.</p>
<h3>Stable</h3>
<p>Bioscript is built as a language from the ground-up with stability in mind. A bioscript written today should be able to run 10 years from now. This means we tightly control code environment of bioscript to ensure that protocols just <i>keep working</i>.
<p>This allows users to be sure that biological experiments that run today will also run in the future.</p>
<p><b>Note:</b> Bioscript will be stable in version 1.0.0. Beta will be unstable as we build out the system.</p>
<hr>
</div>

<div id="protocols">
<h2>Protocols</h2>
<p>Here is a simple example bioscript program, which would prompt a robotic system to make 50mL of a 1M CaCl2/MgCl2 solution.</p>
<pre><code class="language-lua">protocol = new_protocol("make 50mL of 1M CaCl2 / 1M MgCl2")

water_one_L = chemicals["H2O"] * 1 * L		-- 1L H2O
cacl2_one_mol = chemicals["CaCl2"] * 1 * mol	-- 1mol CaCl2
mgcl2_one_mol = chemicals["MgCl2"] * 1 * mol	-- 1mol MgCl2
cacl2_mgcl2_one_M = water_one_L + cacl2_one_mol + mgcl2_one_mol
fifty_mL = cacl2_mgcl2_one_M:volume(50*mL) 	-- Make 50mL of 1M CaCl2 / MgCl2

protocol:make_mixture{mixture=fifty_mL}
protocol:simulate()</code></pre>

<p>Complex premade mixtures, like M9 defined media, are available as common_reagents. For example, to make a 100mL of M9 media.</p>
<pre><code class="language-lua">protocol = new_protocol("make 100mL of M9 media")

m9_hundred_mL = common_reagents["M9"]:volume(100*mL)

protocol:make_mixture{mixture=m9_hundred_mL}
protocol:simulate()</code></pre>
<hr>
</div>

<div id="mixtures">
<h2>Mixtures</h2>
<p>To view default chemicals, use the code: <code class="language-lua">print_all_chemicals()</code></p>
<hr>
</div>



<div id="repl">
<h2>repl</h2>
<p>Below is an in-browser bioscript read–eval–print loop (REPL). This REPL is an open local-only playground for you to learn how bioscript works. Click on it and play around!</p>
<p>Hint: try to copy paste examples above to see what they do</p>

<section class="section--standalone">
    <div class="repl">
        <code id="fengari-console"></code>
        <div class="fengari-input-container">
            <label id="fengari-prompt" for="fengari-input">→ </label>
            <textarea class="lua" id="fengari-input" rows="8" placeholder="Type bioscript here"></textarea>
        </div>
    </div>
</section>
<script src="docs/fengari-web.js" type="text/javascript"></script>
<script src="docs/web-cli.lua" type="application/lua" async></script>
<script type="application/lua" async>
std = require("build.bioscript")
synbio = std.synbio

chemicals = std.mixtures.chemicals
common_reagents = std.mixtures.common_reagents
print_all_chemicals = std.mixtures.print_all_chemicals

new_protocol = std.biologic_commands.new_protocol

mol = std.conversions.mol
mmol = std.conversions.mmol
umol = std.conversions.umol
nmol = std.conversions.nmol
pmol = std.conversions.pmol
fmol = std.conversions.fmol
amol = std.conversions.amol
L = std.conversions.l
mL = std.conversions.ml
uL = std.conversions.ul
nL = std.conversions.nl
kg = std.conversions.kg
g = std.conversions.g
mg = std.conversions.mg
ug = std.conversions.ug
ng = std.conversions.ng
pg = std.conversions.pg
fg = std.conversions.fg

function table_print (tt, indent, done)
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    local sb = {}
    for key, value in pairs (tt) do
      table.insert(sb, string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        table.insert(sb, key .. " = {\n");
        table.insert(sb, table_print (value, indent + 2, done))
        table.insert(sb, string.rep (" ", indent)) -- indent it
        table.insert(sb, "}\n");
      elseif "number" == type(key) then
        table.insert(sb, string.format("\"%s\"\n", tostring(value)))
      elseif "function" ~= type(value) then
        table.insert(sb, string.format(
            "%s = \"%s\"\n", tostring (key), tostring(value)))
       end
    end
    return table.concat(sb)
  else
    return tt .. "\n"
  end
end

function to_string( tbl )
    if  "nil"       == type( tbl ) then
        return tostring(nil)
    elseif  "table" == type( tbl ) then
        return table_print(tbl)
    elseif  "string" == type( tbl ) then
        return tbl
    else
        return tostring(tbl)
    end
end
</script>
</div>


</div></div>

</body>


</html>
